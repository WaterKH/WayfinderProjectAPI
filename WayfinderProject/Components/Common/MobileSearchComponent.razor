@inject IJSRuntime JS

<label style="font-size: larger; margin-top: 10px;"><strong>@Name</strong></label>
@if (this.CurrentView == "Available")
{
    @if (this.AllowMultipleSelect)
    {
        <input class="wayfinder-input" oninput="@((ChangeEventArgs t) => this.UpdateFilteredAvailable(t.Value?.ToString() ?? string.Empty))" placeholder="Filter List..." />
        <select id="@($"Available-{Id}")" class="wayfinder-select" multiple @onchange="@(() => this.Select($"Available-{Id}"))">
            @foreach (var item in this.Available)
            {
                <option class="wayfinder-option" value="@item">@item</option>
            }
        </select>
    }
    else
    {
        <input class="wayfinder-input" oninput="@((ChangeEventArgs t) => this.UpdateFilteredAvailable(t.Value?.ToString() ?? string.Empty))" placeholder="Filter List..." />
        <select id="@($"Available-{Id}")" class="wayfinder-select" @onchange="@(() => this.Select($"Available-{Id}"))">
            @foreach (var item in this.Available)
            {
                <option class="wayfinder-option" value="@item">@item</option>
            }
        </select>
    }
}
else if (this.CurrentView == "Selected")
{
    @if (this.AllowMultipleSelect)
    {
        <select id="@($"Selected-{Id}")" class="wayfinder-select" multiple @onchange="@(() => this.Remove($"Selected-{Id}"))">
            @foreach (var item in this.Selected)
            {
                <option class="wayfinder-option" value="@item">@item</option>
            }
        </select>
    }
    else
    {
        <select id="@($"Selected-{Id}")" class="wayfinder-select" @onchange="@(() => this.Remove($"Selected-{Id}"))">
            @foreach (var item in this.Selected)
            {
                <option class="wayfinder-option" value="@item">@item</option>
            }
        </select>
    }
}

@code {
    [Parameter] public string Id { get; set; } = string.Empty;
    [Parameter] public string Name { get; set; } = string.Empty;
    [Parameter] public List<string> Initial { get; set; } = new List<string>();
    [Parameter] public List<string> Available { get; set; } = new List<string>();
    [Parameter] public List<string> Selected { get; set; } = new List<string>();

    [Parameter] public string CurrentView { get; set; } = "Available";
    [Parameter] public bool AllowMultipleSelect { get; set; } = true;

    [Parameter] public Func<Task>? UpdateSearch { get; set; }

    protected override async Task OnInitializedAsync()
    {
        await base.OnInitializedAsync();
    }

    private async Task Select(string id)
    {
        var values = await JS.InvokeAsync<string[]>("getSelections", id);

        this.Selected.AddRange(values);

        foreach (var value in values)
        {
            this.Available.Remove(value);
        }

        if (this.UpdateSearch != null)
        {
            await Task.Run(async () => await this.UpdateSearch.Invoke());
        }

        await InvokeAsync(() =>
        {
            this.StateHasChanged();
        });
    }

    private async Task Remove(string id)
    {
        var values = await JS.InvokeAsync<string[]>("getSelections", id);

        foreach (var value in values)
        {
            this.Selected.Remove(value);
        }

        this.Available.AddRange(values);
        this.Available.Sort();

        if (this.UpdateSearch != null)
        {
            await Task.Run(async () => await this.UpdateSearch.Invoke());
        }

        await InvokeAsync(() =>
        {
            this.StateHasChanged();
        });
    }

    private async Task UpdateFilteredAvailable(string search)
    {
        this.Available = new List<string>();

        foreach (var selection in this.Initial)
        {
            if (this.Selected.Contains(selection)) continue;

            if (string.IsNullOrEmpty(search) || selection.ToLower().Contains(search.ToLower()))
            {
                this.Available.Add(selection);
            }
        }

        await InvokeAsync(() =>
        {
            this.StateHasChanged();
        });
    }
}