@page "/jiminy_journal"
@inject WayfinderProjectAPI.Data.WayfinderContext context
@inject NavigationManager NavigationManager

@inject IJSRuntime JS
@inject IToastService toastService


@using Microsoft.EntityFrameworkCore
@using WayfinderProjectAPI.Data.DTOs
@using WayfinderProjectAPI.Controllers

<PageTitle>The Wayfinder Project - Jiminy's Journal</PageTitle>

<br/>
<br/>

<div class="wayfinder-background">
    <div class="wayfinder-parallax">
        <div class="row" style="width: 100%; margin: 0px 0px 30px 0px">
            <div class="col-md-12" style="align-self: center;">
                <div class="wayfinder-title">
                    <img src="/images/wayfinder_project_title.png" />
                </div>

                <div class="wayfinder-description">
                    <strong>Search for a <span style="color: #522aff;">Word</span> or <span style="color: #ff7519;">Phrase</span>...</strong>
                </div>

                <div class="wayfinder-search">
                    <span class="wayfinder-search-icon material-icons">search</span>
                    <input id="main-search" name="main-search" class="custom-input" onchange="@((ChangeEventArgs e) => { this.informationSearch = e?.Value?.ToString(); this.SearchInformation(e?.Value?.ToString()); })" placeholder="Start Typing..." >
                    <button class="wayfinder-search-button" onclick="@(() => this.SearchInformation(this.informationSearch))">Search</button>
                </div>

                <div class="wayfinder-sub-description">
                    <strong>
                        Or use a combination of filters below to search through <span style="color: #949dff;">Games</span>, <span style="color: #e685da;">Titles</span> or <span style="color: #ea4a4a;">Characters</span>.
                    </strong>
                </div>
            </div>
        </div>

        <hr />

        <div class="row" style="width: 100%; margin: 0px 0px 30px 0px">
            <div class="col-md-1"></div>

            <div class="col-md-4" style="text-align: center;">
                <div class="wayfinder-title">
                    <strong><span style="color: #522aff;">Daily Journal Entry</span></strong>
                </div>

                <div class="wayfinder-alt-description">
                    <strong>
                        Discover a brand new daily journal entry by visiting The Wayfinder Project everyday! Follow <a href="https://twitter.com/WFP_KH" target="_blank">@@WPF_KH on Twitter</a>!
                    </strong>
                </div>

                <br />

                <button class="wayfinder-button" onclick="@(() => this.NavigateToDailyJournalEntry())" @onclick:stopPropagation>Daily Journal Entry</button>
            </div>

            <div class="col-md-2"></div>

            <div class="col-md-4" style="text-align: center;">
                <div class="wayfinder-title">
                    <strong><span style="color: #ea4a4a;">Random</span> <span style="color: #2cce78;">Entry</span> <span style="color: #5499fc;">Generator</span></strong>
                </div>

                <div class="wayfinder-alt-description">
                    <strong>
                        Can't decide which scene you want to find? Let us choose for you by selecting a random journal entry!
                    </strong>
                </div>

                <br />

                <button class="wayfinder-button" onclick="@(() => this.NavigateToRandomJournalEntry())" @onclick:stopPropagation>Random Journal Entry</button>
            </div>

            <div class="col-md-1"></div>
        </div>
    </div>
</div>


<NavBar @ref="WayfinderNavBar" Categories="this.categories" UpdateCurrentCategory="@(async (string category) => await UpdateCurrentCategory(category))" StartingCategory="@this.CurrentCategory" />
<SubNavBar @ref="WayfinderSubNavBar" Options="this.options" UpdateCurrentOption="@(async (string option) => await UpdateCurrentOption(option))" StartingOption="@this.CurrentOption" />

<!-- TODO Probably want to convert this SearchComponent into something better - Keep track of selections and available outside of the component -->
<div id="scenes-search" class="advanced-search-box" style="@(this.CurrentCategory == "Characters" ? "display: block;" : "display: none;")">
    <div class="row">
        <div class="col-md-12">
            <SearchComponent @ref="GamesSearch" Id="Games" Placeholder="Start Typing..." Color="#cdd1ff" Initial="this.Games" Selected="this.GamesSelected" Available="this.GamesAvailable" 
                                CanSearch="!this.Loading" CurrentOption="@this.CurrentOption" CanShowClearAll="@this.canDisplayClearAll"
                                UpdateSearch="@(async () => await Search())" ClearAllMethod="@(async (clearString) => await ClearAllOptions(clearString))" />

            <SearchComponent @ref="CharacterTitlesSearch" Id="Titles" Placeholder="Start Typing..." Color="#e685da" Initial="this.CharacterTitles" Selected="this.CharacterTitlesSelected" Available="this.CharacterTitlesAvailable"
                                CanSearch="!this.Loading" CurrentOption="@this.CurrentOption" CanShowClearAll="@this.canDisplayClearAll"
                                UpdateSearch="@(async () => await Search())" ClearAllMethod="@(async (clearString) => await ClearAllOptions(clearString))" />

            <SearchComponent @ref="CharactersSearch" Id="Characters" Placeholder="Start Typing..." Color="#f3b222" Initial="this.Characters" Selected="this.CharactersSelected" Available="this.CharactersAvailable" 
                                CanSearch="!this.Loading" CurrentOption="@this.CurrentOption" CanShowClearAll="@this.canDisplayClearAll"
                                UpdateSearch="@(async () => await Search())" ClearAllMethod="@(async (clearString) => await ClearAllOptions(clearString))" />
        </div>
    </div>
</div>

<br />
<br />

@if (this.Loading)
{
    <div class="row" style="justify-content: center;">
        <div class="loader col-md-12"></div>
    </div>
}
else if (this.CurrentCategory == "Story")
{
    
}
else if (this.CurrentCategory == "Characters" && this.JJCharacterDtos.Count > 0)
{
    <CharacterTable @ref="MainCharacterTable" Items="this.JJCharacterDtos" Context="Character" OpenRowQuery="this.OpenRow">
        <TableHeader>
            <th style="text-align: left;"></th>
            <th><img src="/images/icons/games_gray.png" width="25px" class="header-margins"> <label class="header-label">Game</label></th>
            <th><img src="/images/icons/scenes_gray.png" width="25px" class="header-margins"> <label class="header-label">Title</label></th>
            <th><img src="/images/icons/characters_gray.png" width="25px" class="header-margins"> <label class="header-label">Character</label></th>
        </TableHeader>
        <RowTemplate>
            <CharacterTableRow JJCharacter="@Character" MainTable="@MainCharacterTable" />
        </RowTemplate>
        <ExpandedRowTemplate>
            <CharacterTableExpandedRow JJCharacter="@Character" API="@this.api" GenerateShareLink="@(async () => await GenerateShareLink())" />
        </ExpandedRowTemplate>
    </CharacterTable>
}
else if (this.CurrentCategory == "Enemies")
{
    
}
else if (this.CurrentCategory == "Collectibles")
{
    
}

<span style="margin-bottom: 50px;"></span>


<style>
.advanced-search-box {
    margin-top: 10px;
    padding: 0px 15px 15px 25px;
    border-radius: 30px;
    width: 100%;
    height: auto;
    background-color: #f1f1f1;
}

.clickable {
    float: right; 
    font-size: 1rem; 
    color: #3e79a7; 
    margin-top: 3px; 
    cursor: pointer;
}

.icon {
    font-size: .8rem;
    width: 20px;
    height: 20px;
    border: 1px solid black;
    padding: 4px 5px;
    border-radius: 500px;
    background-color: #bee2ff;
}

.loader {
  border: 16px solid #f3f3f3; /* Light grey */
  border-top: 16px solid #3498db; /* Blue */
  border-radius: 50%;
  width: 120px;
  height: 120px;
  animation: spin 2s linear infinite;
}

@@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}
</style>

@code {
    [CascadingParameter]
    private Task<AuthenticationState> authenticationStateTask { get; set; }

    public bool Loading { get; set; }
    public string CurrentCategory { get; set; } = "Story";
    public string CurrentOption { get; set; } = "Games";
    public string CurrentSubOption { get; set; } = "Details";

    private string informationSearch = "";
    private WayfinderController api;

    #region Query Parameters
    [Parameter]
    [SupplyParameterFromQuery(Name = "character_title")]
    public string[]? CharacterTitleQuery { get; set; }

    [Parameter]
    [SupplyParameterFromQuery(Name = "character")]
    public string[]? CharacterQuery { get; set; }

    [Parameter]
    [SupplyParameterFromQuery(Name = "game")]
    public string[]? GameQuery { get; set; }

    [Parameter]
    [SupplyParameterFromQuery(Name = "open_row")]
    public int OpenRow { get; set; } = -1;

    [Parameter]
    [SupplyParameterFromQuery(Name = "category")]
    public string CategoryQuery { get; set; }
    #endregion Query Parameters

    private List<string> categories = new List<string> { "Story", "Characters", "Enemies", "Collectibles" };
    private NavBar? WayfinderNavBar;

    private List<string> options = new List<string>();
    private SubNavBar? WayfinderSubNavBar;

    private bool canDisplayClearAll;

    #region Character Variables
    private List<JJCharacterDto> JJCharacterDtos = new List<JJCharacterDto>();

    public List<string> CharacterTitles { get; set; } = new List<string>();
    public List<string> Characters { get; set; } = new List<string>();
    public List<string> Games { get; set; } = new List<string>();

    #region Character Search Variables
    private SearchComponent? CharacterTitlesSearch;
    private List<string> CharacterTitlesSelected = new List<string>();
    private List<string> CharacterTitlesAvailable = new List<string>();

    private SearchComponent? CharactersSearch;
    private List<string> CharactersSelected = new List<string>();
    private List<string> CharactersAvailable = new List<string>();
    
    private SearchComponent? GamesSearch;
    private List<string> GamesSelected = new List<string>();
    private List<string> GamesAvailable = new List<string>();
    #endregion Character Search Variables

    private CharacterTable<JJCharacterDto>? MainCharacterTable;
    #endregion Character Variables
    //private Table<TrailerDto>? MainTrailerTable;
    //private Table<InterviewDto>? MainInterviewTable;


    private bool firstLoad = false;
    private bool failed = false;

    protected override async Task OnInitializedAsync()
    {
        var authState = await authenticationStateTask;

        //if (authState.User.Identity == null || !authState.User.Identity.IsAuthenticated)
        //{
        //    NavigationManager.NavigateTo("/Identity/Account/Login", true);
        //}

        this.api = new WayfinderController(null, context);

        await base.OnInitializedAsync();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            try
            {
                await this.ResetOptions();

                Thread.Sleep(1000);

                await this.HandleQueryParams();
            }
            catch (Exception)
            {
                // Catch the SqliteException, do not set firstLoad to true
                this.failed = true;

                await InvokeAsync(() =>
                {
                    this.StateHasChanged();
                });
            }
        }

        if (this.failed)
        {
            try
            {
                Thread.Sleep(1000);

                await this.ResetOptions();

                Thread.Sleep(1000);

                await this.HandleQueryParams();
            }
            catch (Exception)
            {
                // Catch the SqliteException, do not set firstLoad to true
            }
        }

        await base.OnAfterRenderAsync(firstRender);
    }

    public async Task UpdateCurrentCategory(string category)
    {
        this.CurrentCategory = category;

        if (this.CurrentCategory == "Story")
        {
            this.options = new List<string>();
        }
        else if (this.CurrentCategory == "Characters")
        {
            this.options = new List<string> { "Games", "Titles", "Characters" };
        }
        else if (this.CurrentCategory == "Enemies")
        {
            this.options = new List<string>();
        }
        else if (this.CurrentCategory == "Collectibles")
        {
            this.options = new List<string>();
        }

        await this.Search();

        await InvokeAsync(() =>
        {
            this.StateHasChanged();
        });
    }

    public async Task UpdateCurrentOption(string option)
    {
        this.CurrentOption = option;

        await InvokeAsync(() =>
        {
            this.StateHasChanged();
        });
    }

    public async Task SearchInformation(string search)
    {
        if (search.Length < 3)
            this.informationSearch = "";
        else
            this.informationSearch = search;


        if (!this.Loading)
        {
            await this.Search();
        }
    }

    public async Task Search()
    {
        this.Loading = true;

        await InvokeAsync(() => { 
            this.StateHasChanged(); 
        });

        if (this.CurrentCategory == "Story")
        {
            //await this.SearchStoryEntries();
        }
        else if (this.CurrentCategory == "Characters")
        {
            await this.SearchCharacterEntries();
        }
        else if (this.CurrentCategory == "Enemies")
        {
            //await this.SearchEnemyEntries();
        }
        else if (this.CurrentCategory == "Collectibles")
        {
            //await this.SearchCollectibleEntries();
        }

        this.Loading = false;

        await InvokeAsync(() => { 
            this.StateHasChanged(); 
        });
    }

    #region Sub-Search Methods
    private async Task SearchStoryEntries()
    {
    }

    private async Task SearchCharacterEntries()
    {
        var games = this.GamesSearch != null ? string.Join("::", this.GamesSelected) != "" ? string.Join("::", this.GamesSelected) : null : null;
        var characterTitles = this.CharacterTitlesSearch != null ? string.Join("::", this.CharacterTitlesSelected) != "" ? string.Join("::", this.CharacterTitlesSelected) : null : null;
        var characters = this.CharactersSearch != null ? string.Join("::", this.CharactersSelected) != "" ? string.Join("::", this.CharactersSelected) : null : null;
        var information = this.informationSearch != "" ? this.informationSearch : null;

        // TODO Remove this after we add in the pagination limiter?
        if (games == null && characterTitles == null && characters == null && information == null)
        {
            this.JJCharacterDtos = new List<JJCharacterDto>();

            await Task.Run(async () => await this.ResetCharacterEntryOptions());

            this.canDisplayClearAll = false;
        }
        else
        {
            var authState = await authenticationStateTask;
            //var user = this.context.Users.FirstOrDefault(x => x.UserName == authState.User.Identity.Name);

            this.JJCharacterDtos = await this.api.SearchForCharacterEntries(games: games, characterTitles: characterTitles, characters: characters, information: information);

            // Maybe use the above to only call the search function we want to based on what's filled out and not null
            //if (user.ApiCallQuota > 0)
            //{
            //    this.SceneDtos = await this.api.SearchForScenes(games: games, scenes: scenes, worlds: worlds, areas: areas, characters: characters, music: music, line: line);

            //    user.ApiCallQuota -= 1;
            //    context.SaveChanges();

            //    if (user.ApiCallQuota == 2500)
            //    {
            //        toastService.ShowInfo("Used half of API Quota (2500/5000).");
            //    }
            //    else if (user.ApiCallQuota == 500)
            //    {
            //        toastService.ShowInfo("Used almost all of API Quota (500/5000). This resets at the start of each month.");
            //    }
            //    else if (user.ApiCallQuota == 0)
            //    {
            //        toastService.ShowInfo("Used all of API Quota (0/5000). This resets at the start of each month.");
            //    }
            //}
            //else
            //{
            //    // TOAST: Out of API Call Quota, resets monthly.
            //    toastService.ShowError("Reached max calls of API Quota (5000/5000). This resets at the start of each month.");
            //}

            this.UpdateCharacterEntryOptions();


            this.canDisplayClearAll = true;
        }

        if (MainCharacterTable != null)
        {
            MainCharacterTable.CurrentPage = 1;
            MainCharacterTable.CurrentExpandedRow = -1;
        }
    }

    private async Task SearchEnemyEntries()
    {
    }

    private async Task SearchCollectibleEntries()
    {
    }
    #endregion Sub-Search Methods

    public async void UpdateOptions()
    {
        if (this.CurrentCategory == "Story")
        {
            this.UpdateStoryEntryOptions();
        }
        else if (this.CurrentCategory == "Characters")
        {
            this.UpdateCharacterEntryOptions();
        }
        else if (this.CurrentCategory == "Enemies")
        {
            this.UpdateEnemyEntriesOptions();
        }
        else if (this.CurrentCategory == "Collectibles")
        {
            this.UpdateCollectibleEntriesOptions();
        }
    }

    #region Sub-Option Methods
    private void UpdateStoryEntryOptions() { }

    private void UpdateCharacterEntryOptions()
    {
        this.CharacterTitles = this.JJCharacterDtos.Select(y => y.Title).Except(this.CharacterTitlesSelected).Distinct().ToList();
        this.Characters = this.JJCharacterDtos.Select(y => y.Character.Name).Except(this.CharactersSelected).Distinct().ToList();
        this.Games = this.JJCharacterDtos.Select(x => x.Game.Name).Except(this.GamesSelected).Distinct().ToList();

        this.CharacterTitles.Sort();
        this.Characters.Sort();

        this.CharacterTitlesAvailable = this.CharacterTitles;
        this.CharactersAvailable = this.Characters;
        this.GamesAvailable = this.Games;
    }

    private void UpdateEnemyEntriesOptions() { }

    private void UpdateCollectibleEntriesOptions() { }
    #endregion Sub-Option Methods

    public async Task ResetOptions()
    {
        this.Loading = true;

        await InvokeAsync(() => { 
            this.StateHasChanged(); 
        });

        if (this.CurrentCategory == "Story")
        {
            await this.ResetStoryEntryOptions();
        }
        else if (this.CurrentCategory == "Characters")
        {
            await this.ResetCharacterEntryOptions();
        }
        else if (this.CurrentCategory == "Enemies")
        {
            await this.ResetEnemyEntryOptions();
        }
        else if (this.CurrentCategory == "Collectibles")
        {
            await this.ResetCollectibleEntryOptions();
        }

        this.Loading = false;

        await InvokeAsync(() => { 
            this.StateHasChanged(); 
        });
    }

    #region Sub-ResetOption Methods
    private async Task ResetStoryEntryOptions() { }

    private async Task ResetCharacterEntryOptions()
    {
        this.CharacterTitles = await context.JJCharacters.AsNoTracking().Select(x => x.Title).ToListAsync();
        this.Characters = await context.Characters.AsNoTracking().Select(x => x.Name).ToListAsync();
        this.Games = await context.Games.AsNoTracking().OrderBy(x => x.Id).Select(x => x.Name).ToListAsync();

        this.CharacterTitles.Sort();
        this.Characters.Sort();

        this.CharacterTitlesAvailable = this.CharacterTitles;
        this.CharactersAvailable = this.Characters;
        this.GamesAvailable = this.Games;

        this.CharacterTitlesSelected = new List<string>();
        this.GamesSelected = new List<string>();
        this.CharactersSelected = new List<string>();
    }

    private async Task ResetEnemyEntryOptions() { }

    private async Task ResetCollectibleEntryOptions() { }
    #endregion Sub-ResetOption Methods

    public async Task ClearAllOptions(string clearString)
    {
        if (this.CurrentCategory == "Story")
        {
            await this.ClearAllStoryEntryOptions(clearString);
        }
        else if (this.CurrentCategory == "Characters")
        {
            await this.ClearAllCharacterEntryOptions(clearString);
        }
        else if (this.CurrentCategory == "Enemies")
        {
            await this.ClearAllEnemyEntryOptions(clearString);
        }
        else if (this.CurrentCategory == "Collectibles")
        {
            await this.ClearAllCollectibleEntryOptions(clearString);
        }

        await this.Search();
    }

    #region Clear All Sub-Methods
    private async Task ClearAllStoryEntryOptions(string clearString) { }

    private async Task ClearAllCharacterEntryOptions(string clearString)
    {
        if (clearString == "Character Titles")
        {
            this.CharacterTitles = await context.JJCharacters.AsNoTracking().Select(x => x.Title).ToListAsync();
            this.CharacterTitles.Sort();

            this.CharacterTitlesAvailable = this.CharacterTitles;
            this.CharacterTitlesSelected = new List<string>();
            await this.CharacterTitlesSearch.SetCurrentView("Available");
        }
        else if (clearString == "Games")
        {
            this.Games = await context.Games.AsNoTracking().OrderBy(x => x.Id).Select(x => x.Name).ToListAsync();

            this.GamesAvailable = this.Games;
            this.GamesSelected = new List<string>();
            await this.GamesSearch.SetCurrentView("Available");
        }
        else if (clearString == "Characters")
        {
            this.Characters = await context.Characters.AsNoTracking().Select(x => x.Name).ToListAsync();
            this.Characters.Sort();

            this.CharactersAvailable = this.Characters;
            this.CharactersSelected = new List<string>();
            await this.CharactersSearch.SetCurrentView("Available");
        }
        else
        {
            await this.ResetOptions();

            await this.CharacterTitlesSearch.SetCurrentView("Available");
            await this.GamesSearch.SetCurrentView("Available");
            await this.CharactersSearch.SetCurrentView("Available");
        }
    }

    private async Task ClearAllEnemyEntryOptions(string clearString) { }

    private async Task ClearAllCollectibleEntryOptions(string clearString) { }
    #endregion Clear All Sub-Methods

    public async Task GenerateShareLink()
    {
        try
        {
            if (this.CurrentCategory == "Story")
            {
                await this.GenerateStoryEntryShareLink();
            }
            else if (this.CurrentCategory == "Characters")
            {
                await this.GenerateCharacterEntryShareLink();
            }
            else if (this.CurrentCategory == "Enemies")
            {
                await this.GenerateEnemyEntryShareLink();
            }
            else if (this.CurrentCategory == "Collectibles")
            {
                await this.GenerateCollectibleEntryShareLink();
            }
        }
        catch (Exception)
        {
            // Catch potential issue when trying to access disposed object
        }

        await InvokeAsync(() =>
        {
            this.StateHasChanged();
        });
    }

    #region Generate Share Link Sub-Methods
    private async Task GenerateStoryEntryShareLink() { }

    private async Task GenerateCharacterEntryShareLink()
    {
        var shareLink = $"{NavigationManager.BaseUri}jiminy_journal?";

        if (this.CharactersSelected.Count > 0)
        {
            shareLink += string.Join("&", this.CharactersSelected.Select(x => $"character={this.context.Characters.AsNoTracking().FirstOrDefault(y => y.Name == x)?.Id}")) + "&";
        }

        if (this.GamesSelected.Count > 0)
        {
            shareLink += string.Join("&", this.GamesSelected.Select(x => $"game={this.context.Games.AsNoTracking().FirstOrDefault(y => y.Name == x)?.Id}")) + "&";
        }

        if (this.CharacterTitlesSelected.Count > 0)
        {
            shareLink += string.Join("&", this.CharacterTitlesSelected.Select(x => $"character_title={this.context.JJCharacters.AsNoTracking().FirstOrDefault(y => y.Title == x)?.Id}")) + "&";
        }

        shareLink += "category=Characters&";
        shareLink += $"open_row={this.MainCharacterTable?.CurrentExpandedRow}";

        await JS.InvokeVoidAsync("navigator.clipboard.writeText", shareLink);

        toastService.ShowInfo($"Copied link to '{this.context.JJCharacters.FirstOrDefault(x => x.Id == this.MainCharacterTable.CurrentExpandedRow)?.Title}' entry.");
    }

    private async Task GenerateEnemyEntryShareLink() { }

    private async Task GenerateCollectibleEntryShareLink() { }
    #endregion Generate Share Link Sub-Methods

    public async Task<bool> HandleQueryParams()
    {
        var optionUpdated = false;

        await InvokeAsync(() =>
        {
            this.StateHasChanged();
        });

        try
        {
            if (this.CurrentCategory == "Story")
            {
                optionUpdated = this.HandleStoryEntryQueryParams();
            }
            else if (this.CurrentCategory == "Characters")
            {
                optionUpdated = await this.HandleCharacterEntryQueryParams();
            }
            else if (this.CurrentCategory == "Enemies")
            {
                optionUpdated = this.HandleEnemyEntryQueryParams();
            }
            else if (this.CurrentCategory == "Collectibles")
            {
                optionUpdated = this.HandleCollectibleEntryQueryParams();
            }

            if (optionUpdated)
            {
                await this.Search();
            }
        }
        catch(Exception ex)
        {
            //this.failed = true;
        }

        await InvokeAsync(() => { 
            this.StateHasChanged(); 
        });

        return optionUpdated;
    }

    #region Handle Query Params Sub-Methods
    private bool HandleStoryEntryQueryParams() { return false; }

    private async Task<bool> HandleCharacterEntryQueryParams()
    {
        var optionUpdated = false;

        if (this.CharacterQuery != null && this.CharacterQuery.Count() > 0)
        {
            var characterIds = this.CharacterQuery.Select(x => int.Parse(x));

            this.CharactersSelected = this.context.Characters.AsNoTracking().Where(x => characterIds.Contains(x.Id)).Select(x => x.Name).ToList();
            await this.CharactersSearch.SetCurrentView("Selected");

            optionUpdated = true;
        }

        if (this.GameQuery != null && this.GameQuery.Count() > 0)
        {
            var gameIds = this.GameQuery.Select(x => int.Parse(x));

            this.GamesSelected = this.context.Games.AsNoTracking().Where(x => gameIds.Contains(x.Id)).OrderBy(x => x.Id).Select(x => x.Name).ToList();
            await this.GamesSearch.SetCurrentView("Selected");

            optionUpdated = true;
        }

        if (this.CharacterTitleQuery != null && this.CharacterTitleQuery.Count() > 0)
        {
            var characterTitleIds = this.CharacterTitleQuery.Select(x => int.Parse(x));

            this.CharacterTitlesSelected = this.context.JJCharacters.AsNoTracking().Where(x => characterTitleIds.Contains(x.Id)).Select(x => x.Title).ToList();
            await this.CharacterTitlesSearch.SetCurrentView("Selected");

            optionUpdated = true;
        }

        if (this.CategoryQuery != null)
        {
            this.CurrentCategory = this.CategoryQuery;
        }

        return optionUpdated;
    }

    private bool HandleEnemyEntryQueryParams() { return false; }

    private bool HandleCollectibleEntryQueryParams() { return false; }
    #endregion Handle Query Params Sub-Methods

    #region Scene Specific Methods
    public async void NavigateToDailyJournalEntry()
    {
        try
        {
            var dateCode = DateTime.Now.ToString("yyyyMMdd");
            //var jjCharacterId = this.context.DailyJournalEntries.FirstOrDefault(character => character.DateCode == dateCode)?.SceneId;
            //var jjCharacter = this.context.JJCharacters.AsNoTracking()
            //    .Include(c => c.Character).Include(c => c.Game)
            //    .FirstOrDefault(c => c.Id == jjCharacterId);

            //var dailyLink = $"{NavigationManager.BaseUri}jiminy_journal?";

            //dailyLink += string.Join("&", scene.Characters.Select(x => $"character={x.Id}")) + "&";
            //dailyLink += string.Join("&", scene.Areas.Select(x => $"area={x.Id}")) + "&";
            //dailyLink += $"game={scene.Game.Id}&";
            //dailyLink += string.Join("&", scene.Music.Select(x => $"music={x.Id}")) + "&";
            //dailyLink += $"scene={scene.Id}&";
            //dailyLink += string.Join("&", scene.Worlds.Select(x => $"world={x.Id}")) + "&";
            //dailyLink += "category=Characters&";
            //dailyLink += $"open_row={scene.Id}";

            //NavigationManager.NavigateTo(dailyLink, true);
        }
        catch (Exception)
        {

        }
    }

    public async void NavigateToRandomJournalEntry()
    {
        try
        {
            Random random = new Random((int)DateTime.Now.Ticks);
            //var randomSceneId = random.Next(0, this.context.Scenes.Count());
            //var scene = this.context.Scenes.AsNoTracking()
            //    .Include(s => s.Characters).Include(s => s.Areas).Include(s => s.Game).Include(s => s.Music).Include(s => s.Worlds)
            //    .FirstOrDefault(s => s.Id == randomSceneId);

            //var randomLink = $"{NavigationManager.BaseUri}memory_archive?";

            //randomLink += string.Join("&", scene.Characters.Select(x => $"character={x.Id}")) + "&";
            //randomLink += string.Join("&", scene.Areas.Select(x => $"area={x.Id}")) + "&";
            //randomLink += $"game={scene.Game.Id}&";
            //randomLink += string.Join("&", scene.Music.Select(x => $"music={x.Id}")) + "&";
            //randomLink += $"scene={scene.Id}&";
            //randomLink += string.Join("&", scene.Worlds.Select(x => $"world={x.Id}")) + "&"; 
            //randomLink += "category=Scenes&";
            //randomLink += $"open_row={scene.Id}";

            //NavigationManager.NavigateTo(randomLink, true);
        }
        catch (Exception)
        {

        }
    }
    #endregion Scene Specific Methods


    #region Search Helpers
    private void Search(string search, ref List<string> initialValues, ref List<string> selected, ref List<string> available)
    {
        available = new List<string>();

        if (string.IsNullOrEmpty(search))
        {
            available = initialValues;
            return;
        }

        foreach (var value in initialValues)
        {
            if (selected.Contains(value)) continue;

            if (value.ToLower().Contains(search.ToLower()))
            {
                available.Add(value);
            }
        }

        available.Sort();
    }

    private void Select(string value, ref List<string> selected, ref List<string> available)
    {
        selected.Add(value);
        available.Remove(value);

        selected.Sort();

        this.Search().Wait();
    }

    private void Remove(string value, ref List<string> selected, ref List<string> available)
    {
        available.Add(value);
        selected.Remove(value);

        available.Sort();

        this.Search().Wait();
    }
    #endregion Search Helpers
}